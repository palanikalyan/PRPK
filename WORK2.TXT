// Service Classes for Crypto Trading Platform

// UserService.java
package com.cryptotrading.service;

import com.cryptotrading.model.User;
import com.cryptotrading.utils.DatabaseConnection;
import com.cryptotrading.utils.CryptographyUtils;
import com.cryptotrading.utils.ValidationUtils;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class UserService {
    
    public User registerUser(String username, String pin, String email, String phoneNumber) throws SQLException {
        if (!ValidationUtils.isValidUsername(username)) {
            throw new IllegalArgumentException("Invalid username format");
        }
        if (!ValidationUtils.isValidPin(pin)) {
            throw new IllegalArgumentException("PIN must be 4-8 digits");
        }
        if (!ValidationUtils.isValidEmail(email)) {
            throw new IllegalArgumentException("Invalid email format");
        }
        
        Connection conn = DatabaseConnection.getConnection();
        
        // Check if username or email already exists
        String checkQuery = "SELECT COUNT(*) FROM DC_Users WHERE username = ? OR email = ?";
        try (PreparedStatement checkStmt = conn.prepareStatement(checkQuery)) {
            checkStmt.setString(1, username);
            checkStmt.setString(2, email);
            ResultSet rs = checkStmt.executeQuery();
            if (rs.next() && rs.getInt(1) > 0) {
                throw new SQLException("Username or email already exists");
            }
        }
        
        // Insert new user
        String insertQuery = "INSERT INTO DC_Users (user_id, username, encrypted_pin, email, phone_number, wallet_address) " +
                            "VALUES (user_seq.NEXTVAL, ?, ?, ?, ?, ?)";
        
        String encryptedPin = CryptographyUtils.hashPin(pin);
        String walletAddress = CryptographyUtils.generateWalletAddress(username, email);
        
        try (PreparedStatement stmt = conn.prepareStatement(insertQuery, new String[]{"user_id"})) {
            stmt.setString(1, username);
            stmt.setString(2, encryptedPin);
            stmt.setString(3, email);
            stmt.setString(4, phoneNumber);
            stmt.setString(5, walletAddress);
            
            int rowsAffected = stmt.executeUpdate();
            if (rowsAffected > 0) {
                ResultSet generatedKeys = stmt.getGeneratedKeys();
                if (generatedKeys.next()) {
                    Long userId = generatedKeys.getLong(1);
                    
                    // Create default wallets for major cryptocurrencies
                    WalletService walletService = new WalletService();
                    String[] defaultCurrencies = {"BTC", "ETH", "USDT"};
                    for (String currency : defaultCurrencies) {
                        walletService.createWallet(userId, currency);
                    }
                    
                    DatabaseConnection.commit();
                    return getUserById(userId);
                }
            }
        } catch (SQLException e) {
            DatabaseConnection.rollback();
            throw e;
        }
        
        throw new SQLException("Failed to create user");
    }
    
    public User authenticateUser(String username, String pin) throws SQLException {
        String query = "SELECT user_id, username, encrypted_pin, email, phone_number, kyc_status, " +
                      "wallet_address, created_at, updated_at FROM DC_Users WHERE username = ?";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                String storedPin = rs.getString("encrypted_pin");
                if (CryptographyUtils.verifyPin(pin, storedPin)) {
                    return mapResultSetToUser(rs);
                }
            }
        }
        
        return null; // Authentication failed
    }
    
    public User getUserById(Long userId) throws SQLException {
        String query = "SELECT user_id, username, encrypted_pin, email, phone_number, kyc_status, " +
                      "wallet_address, created_at, updated_at FROM DC_Users WHERE user_id = ?";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, userId);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return mapResultSetToUser(rs);
            }
        }
        
        return null;
    }
    
    public boolean updateUserProfile(Long userId, String email, String phoneNumber) throws SQLException {
        String query = "UPDATE DC_Users SET email = ?, phone_number = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setString(1, email);
            stmt.setString(2, phoneNumber);
            stmt.setLong(3, userId);
            
            int rowsAffected = stmt.executeUpdate();
            DatabaseConnection.commit();
            return rowsAffected > 0;
        } catch (SQLException e) {
            DatabaseConnection.rollback();
            throw e;
        }
    }
    
    private User mapResultSetToUser(ResultSet rs) throws SQLException {
        User user = new User();
        user.setUserId(rs.getLong("user_id"));
        user.setUsername(rs.getString("username"));
        user.setEncryptedPin(rs.getString("encrypted_pin"));
        user.setEmail(rs.getString("email"));
        user.setPhoneNumber(rs.getString("phone_number"));
        user.setKycStatus(rs.getString("kyc_status"));
        user.setWalletAddress(rs.getString("wallet_address"));
        user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
        user.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
        return user;
    }
}

// WalletService.java
package com.cryptotrading.service;

import com.cryptotrading.model.Wallet;
import com.cryptotrading.utils.DatabaseConnection;

import java.math.BigDecimal;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class WalletService {
    
    public Wallet createWallet(Long userId, String currencyCode) throws SQLException {
        String insertQuery = "INSERT INTO DC_Wallets (wallet_id, user_id, currency_code) " +
                            "VALUES (wallet_seq.NEXTVAL, ?, ?)";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(insertQuery, new String[]{"wallet_id"})) {
            stmt.setLong(1, userId);
            stmt.setString(2, currencyCode);
            
            int rowsAffected = stmt.executeUpdate();
            if (rowsAffected > 0) {
                ResultSet generatedKeys = stmt.getGeneratedKeys();
                if (generatedKeys.next()) {
                    Long walletId = generatedKeys.getLong(1);
                    return getWalletById(walletId);
                }
            }
        }
        
        throw new SQLException("Failed to create wallet");
    }
    
    public List<Wallet> getUserWallets(Long userId) throws SQLException {
        String query = "SELECT w.wallet_id, w.user_id, w.currency_code, w.balance, w.status, " +
                      "w.created_at, w.updated_at, c.currency_name, c.symbol " +
                      "FROM DC_Wallets w JOIN DC_Currencies c ON w.currency_code = c.currency_code " +
                      "WHERE w.user_id = ? AND w.status = 'ACTIVE' ORDER BY w.currency_code";
        
        Connection conn = DatabaseConnection.getConnection();
        List<Wallet> wallets = new ArrayList<>();
        
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, userId);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                wallets.add(mapResultSetToWallet(rs));
            }
        }
        
        return wallets;
    }
    
    public Wallet getUserWallet(Long userId, String currencyCode) throws SQLException {
        String query = "SELECT wallet_id, user_id, currency_code, balance, status, created_at, updated_at " +
                      "FROM DC_Wallets WHERE user_id = ? AND currency_code = ? AND status = 'ACTIVE'";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, userId);
            stmt.setString(2, currencyCode);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return mapResultSetToWallet(rs);
            }
        }
        
        return null;
    }
    
    public boolean updateBalance(Long userId, String currencyCode, BigDecimal newBalance) throws SQLException {
        String query = "UPDATE DC_Wallets SET balance = ?, updated_at = CURRENT_TIMESTAMP " +
                      "WHERE user_id = ? AND currency_code = ? AND status = 'ACTIVE'";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setBigDecimal(1, newBalance);
            stmt.setLong(2, userId);
            stmt.setString(3, currencyCode);
            
            return stmt.executeUpdate() > 0;
        }
    }
    
    public boolean addToBalance(Long userId, String currencyCode, BigDecimal amount) throws SQLException {
        Wallet wallet = getUserWallet(userId, currencyCode);
        if (wallet == null) {
            // Create wallet if it doesn't exist
            wallet = createWallet(userId, currencyCode);
        }
        
        BigDecimal newBalance = wallet.getBalance().add(amount);
        return updateBalance(userId, currencyCode, newBalance);
    }
    
    public boolean deductFromBalance(Long userId, String currencyCode, BigDecimal amount) throws SQLException {
        Wallet wallet = getUserWallet(userId, currencyCode);
        if (wallet == null || wallet.getBalance().compareTo(amount) < 0) {
            return false; // Insufficient balance
        }
        
        BigDecimal newBalance = wallet.getBalance().subtract(amount);
        return updateBalance(userId, currencyCode, newBalance);
    }
    
    private Wallet getWalletById(Long walletId) throws SQLException {
        String query = "SELECT wallet_id, user_id, currency_code, balance, status, created_at, updated_at " +
                      "FROM DC_Wallets WHERE wallet_id = ?";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, walletId);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return mapResultSetToWallet(rs);
            }
        }
        
        return null;
    }
    
    private Wallet mapResultSetToWallet(ResultSet rs) throws SQLException {
        Wallet wallet = new Wallet();
        wallet.setWalletId(rs.getLong("wallet_id"));
        wallet.setUserId(rs.getLong("user_id"));
        wallet.setCurrencyCode(rs.getString("currency_code"));
        wallet.setBalance(rs.getBigDecimal("balance"));
        wallet.setStatus(rs.getString("status"));
        wallet.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
        wallet.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
        return wallet;
    }
}

// TradingService.java
package com.cryptotrading.service;

import com.cryptotrading.model.Transaction;
import com.cryptotrading.model.Currency;
import com.cryptotrading.utils.DatabaseConnection;
import com.cryptotrading.utils.CryptographyUtils;
import com.cryptotrading.utils.ValidationUtils;
import com.cryptotrading.utils.Constants;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class TradingService {
    private final WalletService walletService;
    private final CurrencyService currencyService;
    
    public TradingService() {
        this.walletService = new WalletService();
        this.currencyService = new CurrencyService();
    }
    
    public Transaction buycryptocurrency(Long userId, String currencyCode, BigDecimal amount, BigDecimal pricePerUnit) throws SQLException {
        if (!ValidationUtils.isValidAmount(amount)) {
            throw new IllegalArgumentException("Invalid amount");
        }
        
        BigDecimal totalCost = amount.multiply(pricePerUnit);
        BigDecimal tradingFee = totalCost.multiply(Constants.TRADING_FEE_PERCENTAGE);
        BigDecimal totalWithFee = totalCost.add(tradingFee);
        
        Connection conn = DatabaseConnection.getConnection();
        
        try {
            // Check if user has sufficient USDT balance (assuming USDT is the base currency)
            if (!walletService.deductFromBalance(userId, "USDT", totalWithFee)) {
                throw new SQLException("Insufficient USDT balance");
            }
            
            // Add cryptocurrency to user's wallet
            if (!walletService.addToBalance(userId, currencyCode, amount)) {
                // Rollback USDT deduction
                walletService.addToBalance(userId, "USDT", totalWithFee);
                throw new SQLException("Failed to add cryptocurrency to wallet");
            }
            
            // Create transaction record
            Transaction transaction = new Transaction();
            transaction.setUserId(userId);
            transaction.setTransactionType(Constants.TX_BUY);
            transaction.setFromCurrency("USDT");
            transaction.setToCurrency(currencyCode);
            transaction.setAmount(amount);
            transaction.setPricePerUnit(pricePerUnit);
            transaction.setTotalValue(totalCost);
            transaction.setTransactionFee(tradingFee);
            transaction.setStatus(Constants.STATUS_COMPLETED);
            transaction.setTransactionHash(CryptographyUtils.generateTransactionHash(
                userId + currencyCode + amount.toString() + System.currentTimeMillis()));
            transaction.setCompletedAt(LocalDateTime.now());
            
            Transaction savedTransaction = saveTransaction(transaction);
            DatabaseConnection.commit();
            
            return savedTransaction;
            
        } catch (SQLException e) {
            DatabaseConnection.rollback();
            throw e;
        }
    }
    
    public Transaction sellCryptocurrency(Long userId, String currencyCode, BigDecimal amount, BigDecimal pricePerUnit) throws SQLException {
        if (!ValidationUtils.isValidAmount(amount)) {
            throw new IllegalArgumentException("Invalid amount");
        }
        
        BigDecimal totalValue = amount.multiply(pricePerUnit);
        BigDecimal tradingFee = totalValue.multiply(Constants.TRADING_FEE_PERCENTAGE);
        BigDecimal netValue = totalValue.subtract(tradingFee);
        
        Connection conn = DatabaseConnection.getConnection();
        
        try {
            // Check if user has sufficient cryptocurrency balance
            if (!walletService.deductFromBalance(userId, currencyCode, amount)) {
                throw new SQLException("Insufficient " + currencyCode + " balance");
            }
            
            // Add USDT to user's wallet
            if (!walletService.addToBalance(userId, "USDT", netValue)) {
                // Rollback cryptocurrency deduction
                walletService.addToBalance(userId, currencyCode, amount);
                throw new SQLException("Failed to add USDT to wallet");
            }
            
            // Create transaction record
            Transaction transaction = new Transaction();
            transaction.setUserId(userId);
            transaction.setTransactionType(Constants.TX_SELL);
            transaction.setFromCurrency(currencyCode);
            transaction.setToCurrency("USDT");
            transaction.setAmount(amount);
            transaction.setPricePerUnit(pricePerUnit);
            transaction.setTotalValue(totalValue);
            transaction.setTransactionFee(tradingFee);
            transaction.setStatus(Constants.STATUS_COMPLETED);
            transaction.setTransactionHash(CryptographyUtils.generateTransactionHash(
                userId + currencyCode + amount.toString() + System.currentTimeMillis()));
            transaction.setCompletedAt(LocalDateTime.now());
            
            Transaction savedTransaction = saveTransaction(transaction);
            DatabaseConnection.commit();
            
            return savedTransaction;
            
        } catch (SQLException e) {
            DatabaseConnection.rollback();
            throw e;
        }
    }
    
    public Transaction transferFunds(Long fromUserId, Long toUserId, String currencyCode, BigDecimal amount) throws SQLException {
        if (!ValidationUtils.isValidAmount(amount)) {
            throw new IllegalArgumentException("Invalid amount");
        }
        
        BigDecimal transferFee = amount.multiply(new BigDecimal("0.0005")); // 0.05% transfer fee
        BigDecimal totalDeduction = amount.add(transferFee);
        
        Connection conn = DatabaseConnection.getConnection();
        
        try {
            // Deduct from sender
            if (!walletService.deductFromBalance(fromUserId, currencyCode, totalDeduction)) {
                throw new SQLException("Insufficient balance for transfer");
            }
            
            // Add to receiver
            if (!walletService.addToBalance(toUserId, currencyCode, amount)) {
                // Rollback sender deduction
                walletService.addToBalance(fromUserId, currencyCode, totalDeduction);
                throw new SQLException("Failed to transfer funds to recipient");
            }
            
            // Create transaction record
            Transaction transaction = new Transaction();
            transaction.setUserId(fromUserId);
            transaction.setTransactionType(Constants.TX_TRANSFER);
            transaction.setFromCurrency(currencyCode);
            transaction.setToCurrency(currencyCode);
            transaction.setAmount(amount);
            transaction.setPricePerUnit(BigDecimal.ONE);
            transaction.setTotalValue(amount);
            transaction.setTransactionFee(transferFee);
            transaction.setStatus(Constants.STATUS_COMPLETED);
            transaction.setTransactionHash(CryptographyUtils.generateTransactionHash(
                fromUserId + "" + toUserId + currencyCode + amount.toString() + System.currentTimeMillis()));
            transaction.setCompletedAt(LocalDateTime.now());
            
            Transaction savedTransaction = saveTransaction(transaction);
            DatabaseConnection.commit();
            
            return savedTransaction;
            
        } catch (SQLException e) {
            DatabaseConnection.rollback();
            throw e;
        }
    }
    
    private Transaction saveTransaction(Transaction transaction) throws SQLException {
        String insertQuery = "INSERT INTO DC_Transactions (transaction_id, user_id, transaction_type, " +
                            "from_currency, to_currency, amount, price_per_unit, total_value, transaction_fee, " +
                            "status, transaction_hash, completed_at) VALUES (transaction_seq.NEXTVAL, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(insertQuery, new String[]{"transaction_id"})) {
            stmt.setLong(1, transaction.getUserId());
            stmt.setString(2, transaction.getTransactionType());
            stmt.setString(3, transaction.getFromCurrency());
            stmt.setString(4, transaction.getToCurrency());
            stmt.setBigDecimal(5, transaction.getAmount());
            stmt.setBigDecimal(6, transaction.getPricePerUnit());
            stmt.setBigDecimal(7, transaction.getTotalValue());
            stmt.setBigDecimal(8, transaction.getTransactionFee());
            stmt.setString(9, transaction.getStatus());
            stmt.setString(10, transaction.getTransactionHash());
            stmt.setTimestamp(11, Timestamp.valueOf(transaction.getCompletedAt()));
            
            int rowsAffected = stmt.executeUpdate();
            if (rowsAffected > 0) {
                ResultSet generatedKeys = stmt.getGeneratedKeys();
                if (generatedKeys.next()) {
                    transaction.setTransactionId(generatedKeys.getLong(1));
                    return transaction;
                }
            }
        }
        
        throw new SQLException("Failed to save transaction");
    }
}

// CurrencyService.java
package com.cryptotrading.service;

import com.cryptotrading.model.Currency;
import com.cryptotrading.utils.DatabaseConnection;

import java.math.BigDecimal;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class CurrencyService {
    private final Random random = new Random();
    
    public List<Currency> getAllCurrencies() throws SQLException {
        String query = "SELECT currency_code, currency_name, symbol, blockchain_network, current_price, created_at " +
                      "FROM DC_Currencies ORDER BY currency_name";
        
        Connection conn = DatabaseConnection.getConnection();
        List<Currency> currencies = new ArrayList<>();
        
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                currencies.add(mapResultSetToCurrency(rs));
            }
        }
        
        return currencies;
    }
    
    public Currency getCurrency(String currencyCode) throws SQLException {
        String query = "SELECT currency_code, currency_name, symbol, blockchain_network, current_price, created_at " +
                      "FROM DC_Currencies WHERE currency_code = ?";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setString(1, currencyCode);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return mapResultSetToCurrency(rs);
            }
        }
        
        return null;
    }
    
    public void updateCurrencyPrices() throws SQLException {
        // Simulate market price fluctuations
        List<Currency> currencies = getAllCurrencies();
        
        Connection conn = DatabaseConnection.getConnection();
        String updateQuery = "UPDATE DC_Currencies SET current_price = ? WHERE currency_code = ?";
        
        try (PreparedStatement stmt = conn.prepareStatement(updateQuery)) {
            for (Currency currency : currencies) {
                if (!"USDT".equals(currency.getCurrencyCode())) { // Don't update stablecoin price
                    BigDecimal currentPrice = currency.getCurrentPrice();
                    // Simulate price change between -5% to +5%
                    double changePercent = (random.nextDouble() - 0.5) * 0.1; // -0.05 to +0.05
                    BigDecimal newPrice = currentPrice.multiply(BigDecimal.ONE.add(BigDecimal.valueOf(changePercent)));
                    
                    stmt.setBigDecimal(1, newPrice);
                    stmt.setString(2, currency.getCurrencyCode());
                    stmt.addBatch();
                }
            }
            
            stmt.executeBatch();
            DatabaseConnection.commit();
        } catch (SQLException e) {
            DatabaseConnection.rollback();
            throw e;
        }
    }
    
    private Currency mapResultSetToCurrency(ResultSet rs) throws SQLException {
        Currency currency = new Currency();
        currency.setCurrencyCode(rs.getString("currency_code"));
        currency.setCurrencyName(rs.getString("currency_name"));
        currency.setSymbol(rs.getString("symbol"));
        currency.setBlockchainNetwork(rs.getString("blockchain_network"));
        currency.setCurrentPrice(rs.getBigDecimal("current_price"));
        currency.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
        return currency;
    }
}
