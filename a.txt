# Crypto Trading Platform - Spring Boot Backend

## Project Structure
```
src/main/java/com/crypto/trading/
├── CryptoTradingApplication.java
├── config/
│   ├── DatabaseConfig.java
│   └── SwaggerConfig.java
├── entity/
│   ├── Currency.java
│   ├── User.java
│   ├── Wallet.java
│   ├── Transaction.java
│   ├── SmartContract.java
│   └── BlockchainData.java
├── repository/
│   ├── CurrencyRepository.java
│   ├── UserRepository.java
│   ├── WalletRepository.java
│   ├── TransactionRepository.java
│   ├── SmartContractRepository.java
│   └── BlockchainDataRepository.java
├── service/
│   ├── CurrencyService.java
│   ├── UserService.java
│   ├── WalletService.java
│   ├── TransactionService.java
│   ├── SmartContractService.java
│   └── BlockchainDataService.java
├── controller/
│   ├── CurrencyController.java
│   ├── UserController.java
│   ├── WalletController.java
│   ├── TransactionController.java
│   ├── SmartContractController.java
│   └── BlockchainDataController.java
└── dto/
    ├── UserDto.java
    ├── TransactionDto.java
    └── WalletDto.java
```

## 1. Main Application Class

```java
package com.crypto.trading;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CryptoTradingApplication {
    public static void main(String[] args) {
        SpringApplication.run(CryptoTradingApplication.class, args);
    }
}
```

## 2. Configuration Classes

### Database Configuration
```java
package com.crypto.trading.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;

@Configuration
@EnableJpaRepositories(basePackages = "com.crypto.trading.repository")
@EntityScan(basePackages = "com.crypto.trading.entity")
@EnableTransactionManagement
public class DatabaseConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public JdbcTemplate jdbcTemplate() {
        return new JdbcTemplate(dataSource);
    }
}
```

### Swagger Configuration
```java
package com.crypto.trading.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI cryptoTradingAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Crypto Trading Platform API")
                        .description("REST API for Crypto Trading Platform")
                        .version("1.0")
                        .contact(new Contact()
                                .name("Crypto Trading Team")
                                .email("support@cryptotrading.com")));
    }
}
```

## 3. Entity Classes

### Currency Entity
```java
package com.crypto.trading.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "DC_Currencies")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Currency {

    @Id
    @Column(name = "currency_code", length = 10)
    private String currencyCode;

    @NotNull
    @Column(name = "currency_name", length = 50, nullable = false)
    private String currencyName;

    @NotNull
    @Column(name = "symbol", length = 10, nullable = false)
    private String symbol;

    @Column(name = "blockchain_network", length = 50)
    private String blockchainNetwork;

    @Column(name = "current_price", precision = 18, scale = 8)
    private BigDecimal currentPrice = BigDecimal.ZERO;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
}
```

### User Entity
```java
package com.crypto.trading.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "DC_Users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
    @SequenceGenerator(name = "user_seq", sequenceName = "user_seq", allocationSize = 1)
    @Column(name = "user_id")
    private Long userId;

    @NotNull
    @Column(name = "username", length = 50, nullable = false, unique = true)
    private String username;

    @NotNull
    @Column(name = "encrypted_pin", length = 255, nullable = false)
    private String encryptedPin;

    @Email
    @NotNull
    @Column(name = "email", length = 100, nullable = false, unique = true)
    private String email;

    @Column(name = "phone_number", length = 20)
    private String phoneNumber;

    @Column(name = "kyc_status", length = 20)
    private String kycStatus = "PENDING";

    @Column(name = "wallet_address", length = 100, unique = true)
    private String walletAddress;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Wallet> wallets;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Transaction> transactions;
}
```

### Wallet Entity
```java
package com.crypto.trading.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "DC_Wallets")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Wallet {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "wallet_seq")
    @SequenceGenerator(name = "wallet_seq", sequenceName = "wallet_seq", allocationSize = 1)
    @Column(name = "wallet_id")
    private Long walletId;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "currency_code", nullable = false)
    private Currency currency;

    @Column(name = "balance", precision = 18, scale = 8)
    private BigDecimal balance = BigDecimal.ZERO;

    @Column(name = "status", length = 20)
    private String status = "ACTIVE";

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
```

### Transaction Entity
```java
package com.crypto.trading.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "DC_Transactions")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Transaction {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "transaction_seq")
    @SequenceGenerator(name = "transaction_seq", sequenceName = "transaction_seq", allocationSize = 1)
    @Column(name = "transaction_id")
    private Long transactionId;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @NotNull
    @Column(name = "transaction_type", length = 20, nullable = false)
    private String transactionType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "from_currency")
    private Currency fromCurrency;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "to_currency")
    private Currency toCurrency;

    @NotNull
    @Column(name = "amount", precision = 18, scale = 8, nullable = false)
    private BigDecimal amount;

    @Column(name = "price_per_unit", precision = 18, scale = 8)
    private BigDecimal pricePerUnit;

    @Column(name = "total_value", precision = 18, scale = 8)
    private BigDecimal totalValue;

    @Column(name = "transaction_fee", precision = 18, scale = 8)
    private BigDecimal transactionFee = BigDecimal.ZERO;

    @Column(name = "status", length = 20)
    private String status = "PENDING";

    @Column(name = "transaction_hash", length = 100)
    private String transactionHash;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "completed_at")
    private LocalDateTime completedAt;
}
```

### SmartContract Entity
```java
package com.crypto.trading.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "DC_SmartContracts")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SmartContract {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "contract_seq")
    @SequenceGenerator(name = "contract_seq", sequenceName = "contract_seq", allocationSize = 1)
    @Column(name = "contract_id")
    private Long contractId;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner_id", nullable = false)
    private User owner;

    @NotNull
    @Column(name = "contract_name", length = 100, nullable = false)
    private String contractName;

    @Lob
    @Column(name = "contract_code")
    private String contractCode;

    @Column(name = "status", length = 20)
    private String status = "ACTIVE";

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
}
```

### BlockchainData Entity
```java
package com.crypto.trading.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "DC_BlockchainData")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BlockchainData {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "block_seq")
    @SequenceGenerator(name = "block_seq", sequenceName = "block_seq", allocationSize = 1)
    @Column(name = "block_id")
    private Long blockId;

    @NotNull
    @Column(name = "block_hash", length = 100, nullable = false)
    private String blockHash;

    @Column(name = "previous_hash", length = 100)
    private String previousHash;

    @Column(name = "merkle_root", length = 100)
    private String merkleRoot;

    @CreationTimestamp
    @Column(name = "timestamp_data", updatable = false)
    private LocalDateTime timestampData;

    @Column(name = "difficulty_level")
    private Integer difficultyLevel = 1;

    @Column(name = "nonce")
    private Long nonce = 0L;
}
```

## 4. Repository Interfaces

### CurrencyRepository
```java
package com.crypto.trading.repository;

import com.crypto.trading.entity.Currency;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface CurrencyRepository extends JpaRepository<Currency, String> {
    
    Optional<Currency> findBySymbol(String symbol);
    
    List<Currency> findByBlockchainNetwork(String blockchainNetwork);
    
    @Query("SELECT c FROM Currency c WHERE c.currentPrice > :minPrice")
    List<Currency> findCurrenciesAbovePrice(Double minPrice);
    
    @Query("SELECT c FROM Currency c ORDER BY c.currentPrice DESC")
    List<Currency> findAllOrderByPriceDesc();
}
```

### UserRepository
```java
package com.crypto.trading.repository;

import com.crypto.trading.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByUsername(String username);
    
    Optional<User> findByEmail(String email);
    
    Optional<User> findByWalletAddress(String walletAddress);
    
    List<User> findByKycStatus(String kycStatus);
    
    @Query("SELECT u FROM User u WHERE u.phoneNumber = :phoneNumber")
    Optional<User> findByPhoneNumber(@Param("phoneNumber") String phoneNumber);
    
    @Query("SELECT COUNT(u) FROM User u WHERE u.kycStatus = 'APPROVED'")
    Long countApprovedUsers();
}
```

### WalletRepository
```java
package com.crypto.trading.repository;

import com.crypto.trading.entity.Wallet;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface WalletRepository extends JpaRepository<Wallet, Long> {
    
    List<Wallet> findByUserId(Long userId);
    
    Optional<Wallet> findByUserIdAndCurrencyCurrencyCode(Long userId, String currencyCode);
    
    List<Wallet> findByCurrencyCurrencyCode(String currencyCode);
    
    List<Wallet> findByStatus(String status);
    
    @Query("SELECT w FROM Wallet w WHERE w.balance > :minBalance")
    List<Wallet> findWalletsWithMinBalance(@Param("minBalance") BigDecimal minBalance);
    
    @Query("SELECT SUM(w.balance) FROM Wallet w WHERE w.currency.currencyCode = :currencyCode")
    BigDecimal getTotalBalanceByCurrency(@Param("currencyCode") String currencyCode);
}
```

### TransactionRepository
```java
package com.crypto.trading.repository;

import com.crypto.trading.entity.Transaction;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    List<Transaction> findByUserId(Long userId);
    
    List<Transaction> findByTransactionType(String transactionType);
    
    List<Transaction> findByStatus(String status);
    
    Optional<Transaction> findByTransactionHash(String transactionHash);
    
    @Query("SELECT t FROM Transaction t WHERE t.user.userId = :userId AND t.transactionType = :type")
    List<Transaction> findByUserIdAndTransactionType(@Param("userId") Long userId, @Param("type") String transactionType);
    
    @Query("SELECT t FROM Transaction t WHERE t.createdAt BETWEEN :startDate AND :endDate")
    List<Transaction> findTransactionsBetweenDates(@Param("startDate") LocalDateTime startDate, @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT SUM(t.totalValue) FROM Transaction t WHERE t.status = 'COMPLETED' AND t.transactionType = 'BUY'")
    Double getTotalBuyVolume();
}
```

### SmartContractRepository
```java
package com.crypto.trading.repository;

import com.crypto.trading.entity.SmartContract;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface SmartContractRepository extends JpaRepository<SmartContract, Long> {
    
    List<SmartContract> findByOwnerId(Long ownerId);
    
    List<SmartContract> findByStatus(String status);
    
    List<SmartContract> findByContractNameContaining(String contractName);
    
    @Query("SELECT sc FROM SmartContract sc WHERE sc.owner.userId = :ownerId AND sc.status = :status")
    List<SmartContract> findByOwnerIdAndStatus(@Param("ownerId") Long ownerId, @Param("status") String status);
}
```

### BlockchainDataRepository
```java
package com.crypto.trading.repository;

import com.crypto.trading.entity.BlockchainData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface BlockchainDataRepository extends JpaRepository<BlockchainData, Long> {
    
    Optional<BlockchainData> findByBlockHash(String blockHash);
    
    Optional<BlockchainData> findByPreviousHash(String previousHash);
    
    @Query("SELECT bd FROM BlockchainData bd WHERE bd.timestampData BETWEEN :startDate AND :endDate")
    List<BlockchainData> findBlocksBetweenDates(@Param("startDate") LocalDateTime startDate, @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT bd FROM BlockchainData bd ORDER BY bd.timestampData DESC")
    List<BlockchainData> findAllOrderByTimestampDesc();
    
    @Query("SELECT bd FROM BlockchainData bd WHERE bd.difficultyLevel >= :minDifficulty")
    List<BlockchainData> findBlocksWithMinDifficulty(@Param("minDifficulty") Integer minDifficulty);
}
```

## 5. DTO Classes

### UserDto
```java
package com.crypto.trading.dto;

import lombok.Data;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

@Data
public class UserDto {
    private Long userId;
    
    @NotBlank(message = "Username is required")
    private String username;
    
    @NotBlank(message = "PIN is required")
    private String pin;
    
    @Email(message = "Invalid email format")
    @NotBlank(message = "Email is required")
    private String email;
    
    private String phoneNumber;
    private String kycStatus;
    private String walletAddress;
}
```

### TransactionDto
```java
package com.crypto.trading.dto;

import lombok.Data;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;

import java.math.BigDecimal;

@Data
public class TransactionDto {
    private Long transactionId;
    
    @NotNull(message = "User ID is required")
    private Long userId;
    
    @NotNull(message = "Transaction type is required")
    private String transactionType;
    
    private String fromCurrency;
    private String toCurrency;
    
    @NotNull(message = "Amount is required")
    @Positive(message = "Amount must be positive")
    private BigDecimal amount;
    
    private BigDecimal pricePerUnit;
    private BigDecimal totalValue;
    private BigDecimal transactionFee;
    private String status;
    private String transactionHash;
}
```

### WalletDto
```java
package com.crypto.trading.dto;

import lombok.Data;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

@Data
public class WalletDto {
    private Long walletId;
    
    @NotNull(message = "User ID is required")
    private Long userId;
    
    @NotNull(message = "Currency code is required")
    private String currencyCode;
    
    private BigDecimal balance;
    private String status;
}
```

## 6. Service Classes

### CurrencyService
```java
package com.crypto.trading.service;

import com.crypto.trading.entity.Currency;
import com.crypto.trading.repository.CurrencyRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class CurrencyService {

    @Autowired
    private CurrencyRepository currencyRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<Currency> getAllCurrencies() {
        return currencyRepository.findAll();
    }

    public Optional<Currency> getCurrencyByCode(String currencyCode) {
        return currencyRepository.findById(currencyCode);
    }

    public Optional<Currency> getCurrencyBySymbol(String symbol) {
        return currencyRepository.findBySymbol(symbol);
    }

    public Currency saveCurrency(Currency currency) {
        return currencyRepository.save(currency);
    }

    public void deleteCurrency(String currencyCode) {
        currencyRepository.deleteById(currencyCode);
    }

    public List<Currency> getCurrenciesByNetwork(String network) {
        return currencyRepository.findByBlockchainNetwork(network);
    }

    public void updateCurrencyPrice(String currencyCode, BigDecimal newPrice) {
        String sql = "UPDATE DC_Currencies SET current_price = ? WHERE currency_code = ?";
        jdbcTemplate.update(sql, newPrice, currencyCode);
    }

    public List<Currency> getTopCurrenciesByPrice() {
        return currencyRepository.findAllOrderByPriceDesc();
    }
}
```

### UserService
```java
package com.crypto.trading.service;

import com.crypto.trading.entity.User;
import com.crypto.trading.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public Optional<User> getUserById(Long userId) {
        return userRepository.findById(userId);
    }

    public Optional<User> getUserByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    public Optional<User> getUserByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    public User saveUser(User user) {
        return userRepository.save(user);
    }

    public void deleteUser(Long userId) {
        userRepository.deleteById(userId);
    }

    public List<User> getUsersByKycStatus(String kycStatus) {
        return userRepository.findByKycStatus(kycStatus);
    }

    public void updateKycStatus(Long userId, String kycStatus) {
        String sql = "UPDATE DC_Users SET kyc_status = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?";
        jdbcTemplate.update(sql, kycStatus, userId);
    }

    public Long getApprovedUsersCount() {
        return userRepository.countApprovedUsers();
    }

    public boolean existsByUsername(String username) {
        return userRepository.findByUsername(username).isPresent();
    }

    public boolean existsByEmail(String email) {
        return userRepository.findByEmail(email).isPresent();
    }
}
```

### WalletService
```java
package com.crypto.trading.service;

import com.crypto.trading.entity.Wallet;
import com.crypto.trading.repository.WalletRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class WalletService {

    @Autowired
    private WalletRepository walletRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<Wallet> getAllWallets() {
        return walletRepository.findAll();
    }

    public Optional<Wallet> getWalletById(Long walletId) {
        return walletRepository.findById(walletId);
    }

    public List<Wallet> getWalletsByUserId(Long userId) {
        return walletRepository.findByUserId(userId);
    }

    public Optional<Wallet> getUserWalletByCurrency(Long userId, String currencyCode) {
        return walletRepository.findByUserIdAndCurrencyCurrencyCode(userId, currencyCode);
    }

    public Wallet saveWallet(Wallet wallet) {
        return walletRepository.save(wallet);
    }

    public void deleteWallet(Long walletId) {
        walletRepository.deleteById(walletId);
    }

    public void updateWalletBalance(Long walletId, BigDecimal newBalance) {
        String sql = "UPDATE DC_Wallets SET balance = ?, updated_at = CURRENT_TIMESTAMP WHERE wallet_id = ?";
        jdbcTemplate.update(sql, newBalance, walletId);
    }

    public BigDecimal getTotalBalanceByCurrency(String currencyCode) {
        return walletRepository.getTotalBalanceByCurrency(currencyCode);
    }

    public List<Wallet> getActiveWallets() {
        return walletRepository.findByStatus("ACTIVE");
    }

    public void deactivateWallet(Long walletId) {
        String sql = "UPDATE DC_Wallets SET status = 'INACTIVE', updated_at = CURRENT_TIMESTAMP WHERE wallet_id = ?";
        jdbcTemplate.update(sql, walletId);
    }
}
```

### TransactionService
```java
package com.crypto.trading.service;

import com.crypto.trading.entity.Transaction;
import com.crypto.trading.repository.TransactionRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class TransactionService {

    @Autowired
    private TransactionRepository transactionRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<Transaction> getAllTransactions() {
        return transactionRepository.findAll();
    }

    public Optional<Transaction> getTransactionById(Long transactionId) {
        return transactionRepository.findById(transactionId);
    }

    public List<Transaction> getTransactionsByUserId(Long userId) {
        return transactionRepository.findByUserId(userId);
    }

    public List<Transaction> getTransactionsByType(String transactionType) {
        return transactionRepository.findByTransactionType(transactionType);
    }

    public List<Transaction> getTransactionsByStatus(String status) {
        return transactionRepository.findByStatus(status);
    }

    public Transaction saveTransaction(Transaction transaction) {
        return transactionRepository.save(transaction);
    }

    public void deleteTransaction(Long transactionId) {
        transactionRepository.deleteById(transactionId);
    }

    public void updateTransactionStatus(Long transactionId, String status) {
        String sql = "UPDATE DC_Transactions SET status = ? WHERE transaction_id = ?";
        jdbcTemplate.update(sql, status, transactionId);
    }

    public void completeTransaction(Long transactionId) {
        String sql = "UPDATE DC_Transactions SET status = 'COMPLETED', completed_at = CURRENT_TIMESTAMP WHERE transaction_id = ?";
        jdbcTemplate.update(sql, transactionId);
    }

    public List<Transaction> getTransactionsBetweenDates(LocalDateTime startDate, LocalDateTime endDate) {
        return transactionRepository.findTransactionsBetweenDates(startDate, endDate);
    }

    public Double getTotalBuyVolume() {
        return transactionRepository.getTotalBuyVolume();
    }

    public Optional<Transaction> getTransactionByHash(String transactionHash) {
        return transactionRepository.findByTransactionHash(transactionHash);
    }
}
```

### SmartContractService
```java
package com.crypto.trading.service;

import com.crypto.trading.entity.SmartContract;
import com.crypto.trading.repository.SmartContractRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class SmartContractService {

    @Autowired
    private SmartContractRepository smartContractRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<SmartContract> getAllSmartContracts() {
        return smartContractRepository.findAll();
    }

    public Optional<SmartContract> getSmartContractById(Long contractId) {
        return smartContractRepository.findById(contractId);
    }

    public List<SmartContract> getSmartContractsByOwnerId(Long ownerId) {
        return smartContractRepository.findByOwnerId(ownerId);
    }

    public List<SmartContract> getSmartContractsByStatus(String status) {
        return smartContractRepository.findByStatus(status);
    }

    public SmartContract saveSmartContract(SmartContract smartContract) {
        return smartContractRepository.save(smartContract);
    }

    public void deleteSmartContract(Long contractId) {
        smartContractRepository.deleteById(contractId);
    }

    public void updateContractStatus(Long contractId, String status) {
        String sql = "UPDATE DC_SmartContracts SET status = ? WHERE contract_id = ?";
        jdbcTemplate.update(sql, status, contractId);
    }

    public List<SmartContract> searchContractsByName(String contractName) {
        return smartContractRepository.findByContractNameContaining(contractName);
    }

    public void deactivateContract(Long contractId) {
        updateContractStatus(contractId, "INACTIVE");
    }
}
```

### BlockchainDataService
```java
package com.crypto.trading.service;

import com.crypto.trading.entity.BlockchainData;
import com.crypto.trading.repository.BlockchainDataRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class BlockchainDataService {

    @Autowired
    private BlockchainDataRepository blockchainDataRepository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<BlockchainData> getAllBlocks() {
        return blockchainDataRepository.findAll();
    }

    public Optional<BlockchainData> getBlockById(Long blockId) {
        return blockchainDataRepository.findById(blockId);
    }

    public Optional<BlockchainData> getBlockByHash(String blockHash) {
        return blockchainDataRepository.findByBlockHash(blockHash);
    }

    public BlockchainData saveBlock(BlockchainData blockchainData) {
        return blockchainDataRepository.save(blockchainData);
    }

    public void deleteBlock(Long blockId) {
        blockchainDataRepository.deleteById(blockId);
    }

    public List<BlockchainData> getBlocksBetweenDates(LocalDateTime startDate, LocalDateTime endDate) {
        return blockchainDataRepository.findBlocksBetweenDates(startDate, endDate);
    }

    public List<BlockchainData> getLatestBlocks() {
        return blockchainDataRepository.findAllOrderByTimestampDesc();
    }

    public List<BlockchainData> getBlocksWithMinDifficulty(Integer minDifficulty) {
        return blockchainDataRepository.findBlocksWithMinDifficulty(minDifficulty);
    }
}
```

## 7. Controller Classes

### CurrencyController
```java
package com.crypto.trading.controller;

import com.crypto.trading.entity.Currency;
import com.crypto.trading.service.CurrencyService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/currencies")
@Tag(name = "Currency Management", description = "APIs for managing cryptocurrencies")
public class CurrencyController {

    @Autowired
    private CurrencyService currencyService;

    @GetMapping
    @Operation(summary = "Get all currencies", description = "Retrieve all cryptocurrencies")
    public ResponseEntity<List<Currency>> getAllCurrencies() {
        List<Currency> currencies = currencyService.getAllCurrencies();
        return ResponseEntity.ok(currencies);
    }

    @GetMapping("/{currencyCode}")
    @Operation(summary = "Get currency by code", description = "Retrieve a specific currency by its code")
    public ResponseEntity<Currency> getCurrencyByCode(
            @Parameter(description = "Currency code") @PathVariable String currencyCode) {
        Optional<Currency> currency = currencyService.getCurrencyByCode(currencyCode);
        return currency.map(ResponseEntity::ok)
                      .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/symbol/{symbol}")
    @Operation(summary = "Get currency by symbol", description = "Retrieve a currency by its symbol")
    public ResponseEntity<Currency> getCurrencyBySymbol(
            @Parameter(description = "Currency symbol") @PathVariable String symbol) {
        Optional<Currency> currency = currencyService.getCurrencyBySymbol(symbol);
        return currency.map(ResponseEntity::ok)
                      .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @Operation(summary = "Create new currency", description = "Add a new cryptocurrency")
    public ResponseEntity<Currency> createCurrency(@Valid @RequestBody Currency currency) {
        Currency savedCurrency = currencyService.saveCurrency(currency);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedCurrency);
    }

    @PutMapping("/{currencyCode}")
    @Operation(summary = "Update currency", description = "Update an existing currency")
    public ResponseEntity<Currency> updateCurrency(
            @PathVariable String currencyCode,
            @Valid @RequestBody Currency currency) {
        if (!currencyService.getCurrencyByCode(currencyCode).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        currency.setCurrencyCode(currencyCode);
        Currency updatedCurrency = currencyService.saveCurrency(currency);
        return ResponseEntity.ok(updatedCurrency);
    }

    @DeleteMapping("/{currencyCode}")
    @Operation(summary = "Delete currency", description = "Delete a currency by its code")
    public ResponseEntity<Void> deleteCurrency(@PathVariable String currencyCode) {
        if (!currencyService.getCurrencyByCode(currencyCode).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        currencyService.deleteCurrency(currencyCode);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{currencyCode}/price")
    @Operation(summary = "Update currency price", description = "Update the current price of a currency")
    public ResponseEntity<Void> updateCurrencyPrice(
            @PathVariable String currencyCode,
            @RequestParam BigDecimal newPrice) {
        currencyService.updateCurrencyPrice(currencyCode, newPrice);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/network/{network}")
    @Operation(summary = "Get currencies by network", description = "Get all currencies on a specific blockchain network")
    public ResponseEntity<List<Currency>> getCurrenciesByNetwork(@PathVariable String network) {
        List<Currency> currencies = currencyService.getCurrenciesByNetwork(network);
        return ResponseEntity.ok(currencies);
    }

    @GetMapping("/top")
    @Operation(summary = "Get top currencies", description = "Get currencies ordered by price (highest first)")
    public ResponseEntity<List<Currency>> getTopCurrencies() {
        List<Currency> currencies = currencyService.getTopCurrenciesByPrice();
        return ResponseEntity.ok(currencies);
    }
}
```

### UserController
```java
package com.crypto.trading.controller;

import com.crypto.trading.dto.UserDto;
import com.crypto.trading.entity.User;
import com.crypto.trading.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/users")
@Tag(name = "User Management", description = "APIs for managing users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping
    @Operation(summary = "Get all users", description = "Retrieve all registered users")
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }

    @GetMapping("/{userId}")
    @Operation(summary = "Get user by ID", description = "Retrieve a specific user by ID")
    public ResponseEntity<User> getUserById(
            @Parameter(description = "User ID") @PathVariable Long userId) {
        Optional<User> user = userService.getUserById(userId);
        return user.map(ResponseEntity::ok)
                  .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/username/{username}")
    @Operation(summary = "Get user by username", description = "Retrieve a user by username")
    public ResponseEntity<User> getUserByUsername(@PathVariable String username) {
        Optional<User> user = userService.getUserByUsername(username);
        return user.map(ResponseEntity::ok)
                  .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @Operation(summary = "Register new user", description = "Register a new user")
    public ResponseEntity<?> registerUser(@Valid @RequestBody UserDto userDto) {
        if (userService.existsByUsername(userDto.getUsername())) {
            return ResponseEntity.badRequest().body("Username already exists!");
        }
        if (userService.existsByEmail(userDto.getEmail())) {
            return ResponseEntity.badRequest().body("Email already exists!");
        }
        
        User user = new User();
        user.setUsername(userDto.getUsername());
        user.setEncryptedPin(userDto.getPin()); // In real app, encrypt this
        user.setEmail(userDto.getEmail());
        user.setPhoneNumber(userDto.getPhoneNumber());
        user.setKycStatus("PENDING");
        
        User savedUser = userService.saveUser(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
    }

    @PutMapping("/{userId}")
    @Operation(summary = "Update user", description = "Update an existing user")
    public ResponseEntity<User> updateUser(
            @PathVariable Long userId,
            @Valid @RequestBody UserDto userDto) {
        Optional<User> existingUser = userService.getUserById(userId);
        if (!existingUser.isPresent()) {
            return ResponseEntity.notFound().build();
        }
        
        User user = existingUser.get();
        user.setUsername(userDto.getUsername());
        user.setEmail(userDto.getEmail());
        user.setPhoneNumber(userDto.getPhoneNumber());
        
        User updatedUser = userService.saveUser(user);
        return ResponseEntity.ok(updatedUser);
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "Delete user", description = "Delete a user by ID")
    public ResponseEntity<Void> deleteUser(@PathVariable Long userId) {
        if (!userService.getUserById(userId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        userService.deleteUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{userId}/kyc-status")
    @Operation(summary = "Update KYC status", description = "Update user's KYC status")
    public ResponseEntity<Void> updateKycStatus(
            @PathVariable Long userId,
            @RequestParam String kycStatus) {
        userService.updateKycStatus(userId, kycStatus);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/kyc-status/{status}")
    @Operation(summary = "Get users by KYC status", description = "Get all users with specific KYC status")
    public ResponseEntity<List<User>> getUsersByKycStatus(@PathVariable String status) {
        List<User> users = userService.getUsersByKycStatus(status);
        return ResponseEntity.ok(users);
    }

    @GetMapping("/stats/approved-count")
    @Operation(summary = "Get approved users count", description = "Get count of approved users")
    public ResponseEntity<Long> getApprovedUsersCount() {
        Long count = userService.getApprovedUsersCount();
        return ResponseEntity.ok(count);
    }
}
```

### WalletController
```java
package com.crypto.trading.controller;

import com.crypto.trading.dto.WalletDto;
import com.crypto.trading.entity.Currency;
import com.crypto.trading.entity.User;
import com.crypto.trading.entity.Wallet;
import com.crypto.trading.service.CurrencyService;
import com.crypto.trading.service.UserService;
import com.crypto.trading.service.WalletService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/wallets")
@Tag(name = "Wallet Management", description = "APIs for managing user wallets")
public class WalletController {

    @Autowired
    private WalletService walletService;

    @Autowired
    private UserService userService;

    @Autowired
    private CurrencyService currencyService;

    @GetMapping
    @Operation(summary = "Get all wallets", description = "Retrieve all wallets")
    public ResponseEntity<List<Wallet>> getAllWallets() {
        List<Wallet> wallets = walletService.getAllWallets();
        return ResponseEntity.ok(wallets);
    }

    @GetMapping("/{walletId}")
    @Operation(summary = "Get wallet by ID", description = "Retrieve a specific wallet by ID")
    public ResponseEntity<Wallet> getWalletById(@PathVariable Long walletId) {
        Optional<Wallet> wallet = walletService.getWalletById(walletId);
        return wallet.map(ResponseEntity::ok)
                    .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/user/{userId}")
    @Operation(summary = "Get wallets by user", description = "Get all wallets for a specific user")
    public ResponseEntity<List<Wallet>> getWalletsByUserId(@PathVariable Long userId) {
        List<Wallet> wallets = walletService.getWalletsByUserId(userId);
        return ResponseEntity.ok(wallets);
    }

    @PostMapping
    @Operation(summary = "Create new wallet", description = "Create a new wallet for a user")
    public ResponseEntity<?> createWallet(@Valid @RequestBody WalletDto walletDto) {
        Optional<User> user = userService.getUserById(walletDto.getUserId());
        if (!user.isPresent()) {
            return ResponseEntity.badRequest().body("User not found!");
        }

        Optional<Currency> currency = currencyService.getCurrencyByCode(walletDto.getCurrencyCode());
        if (!currency.isPresent()) {
            return ResponseEntity.badRequest().body("Currency not found!");
        }

        // Check if user already has a wallet for this currency
        Optional<Wallet> existingWallet = walletService.getUserWalletByCurrency(
            walletDto.getUserId(), walletDto.getCurrencyCode());
        if (existingWallet.isPresent()) {
            return ResponseEntity.badRequest().body("User already has a wallet for this currency!");
        }

        Wallet wallet = new Wallet();
        wallet.setUser(user.get());
        wallet.setCurrency(currency.get());
        wallet.setBalance(walletDto.getBalance() != null ? walletDto.getBalance() : BigDecimal.ZERO);
        wallet.setStatus("ACTIVE");

        Wallet savedWallet = walletService.saveWallet(wallet);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedWallet);
    }

    @PutMapping("/{walletId}/balance")
    @Operation(summary = "Update wallet balance", description = "Update the balance of a wallet")
    public ResponseEntity<Void> updateWalletBalance(
            @PathVariable Long walletId,
            @RequestParam BigDecimal newBalance) {
        if (!walletService.getWalletById(walletId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        walletService.updateWalletBalance(walletId, newBalance);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{walletId}")
    @Operation(summary = "Delete wallet", description = "Delete a wallet by ID")
    public ResponseEntity<Void> deleteWallet(@PathVariable Long walletId) {
        if (!walletService.getWalletById(walletId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        walletService.deleteWallet(walletId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{walletId}/deactivate")
    @Operation(summary = "Deactivate wallet", description = "Deactivate a wallet")
    public ResponseEntity<Void> deactivateWallet(@PathVariable Long walletId) {
        if (!walletService.getWalletById(walletId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        walletService.deactivateWallet(walletId);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/currency/{currencyCode}/total-balance")
    @Operation(summary = "Get total balance by currency", description = "Get total balance across all wallets for a currency")
    public ResponseEntity<BigDecimal> getTotalBalanceByCurrency(@PathVariable String currencyCode) {
        BigDecimal totalBalance = walletService.getTotalBalanceByCurrency(currencyCode);
        return ResponseEntity.ok(totalBalance);
    }

    @GetMapping("/active")
    @Operation(summary = "Get active wallets", description = "Get all active wallets")
    public ResponseEntity<List<Wallet>> getActiveWallets() {
        List<Wallet> wallets = walletService.getActiveWallets();
        return ResponseEntity.ok(wallets);
    }
}
```

### TransactionController
```java
package com.crypto.trading.controller;

import com.crypto.trading.dto.TransactionDto;
import com.crypto.trading.entity.Currency;
import com.crypto.trading.entity.Transaction;
import com.crypto.trading.entity.User;
import com.crypto.trading.service.CurrencyService;
import com.crypto.trading.service.TransactionService;
import com.crypto.trading.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/transactions")
@Tag(name = "Transaction Management", description = "APIs for managing transactions")
public class TransactionController {

    @Autowired
    private TransactionService transactionService;

    @Autowired
    private UserService userService;

    @Autowired
    private CurrencyService currencyService;

    @GetMapping
    @Operation(summary = "Get all transactions", description = "Retrieve all transactions")
    public ResponseEntity<List<Transaction>> getAllTransactions() {
        List<Transaction> transactions = transactionService.getAllTransactions();
        return ResponseEntity.ok(transactions);
    }

    @GetMapping("/{transactionId}")
    @Operation(summary = "Get transaction by ID", description = "Retrieve a specific transaction by ID")
    public ResponseEntity<Transaction> getTransactionById(@PathVariable Long transactionId) {
        Optional<Transaction> transaction = transactionService.getTransactionById(transactionId);
        return transaction.map(ResponseEntity::ok)
                         .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/user/{userId}")
    @Operation(summary = "Get transactions by user", description = "Get all transactions for a specific user")
    public ResponseEntity<List<Transaction>> getTransactionsByUserId(@PathVariable Long userId) {
        List<Transaction> transactions = transactionService.getTransactionsByUserId(userId);
        return ResponseEntity.ok(transactions);
    }

    @GetMapping("/type/{transactionType}")
    @Operation(summary = "Get transactions by type", description = "Get all transactions of a specific type")
    public ResponseEntity<List<Transaction>> getTransactionsByType(@PathVariable String transactionType) {
        List<Transaction> transactions = transactionService.getTransactionsByType(transactionType);
        return ResponseEntity.ok(transactions);
    }

    @PostMapping
    @Operation(summary = "Create new transaction", description = "Create a new transaction")
    public ResponseEntity<?> createTransaction(@Valid @RequestBody TransactionDto transactionDto) {
        Optional<User> user = userService.getUserById(transactionDto.getUserId());
        if (!user.isPresent()) {
            return ResponseEntity.badRequest().body("User not found!");
        }

        Transaction transaction = new Transaction();
        transaction.setUser(user.get());
        transaction.setTransactionType(transactionDto.getTransactionType());
        transaction.setAmount(transactionDto.getAmount());
        transaction.setPricePerUnit(transactionDto.getPricePerUnit());
        transaction.setTotalValue(transactionDto.getTotalValue());
        transaction.setTransactionFee(transactionDto.getTransactionFee());
        transaction.setStatus("PENDING");

        // Set currencies if provided
        if (transactionDto.getFromCurrency() != null) {
            Optional<Currency> fromCurrency = currencyService.getCurrencyByCode(transactionDto.getFromCurrency());
            fromCurrency.ifPresent(transaction::setFromCurrency);
        }

        if (transactionDto.getToCurrency() != null) {
            Optional<Currency> toCurrency = currencyService.getCurrencyByCode(transactionDto.getToCurrency());
            toCurrency.ifPresent(transaction::setToCurrency);
        }

        Transaction savedTransaction = transactionService.saveTransaction(transaction);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedTransaction);
    }

    @PutMapping("/{transactionId}/status")
    @Operation(summary = "Update transaction status", description = "Update the status of a transaction")
    public ResponseEntity<Void> updateTransactionStatus(
            @PathVariable Long transactionId,
            @RequestParam String status) {
        if (!transactionService.getTransactionById(transactionId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        transactionService.updateTransactionStatus(transactionId, status);
        return ResponseEntity.ok().build();
    }

    @PutMapping("/{transactionId}/complete")
    @Operation(summary = "Complete transaction", description = "Mark a transaction as completed")
    public ResponseEntity<Void> completeTransaction(@PathVariable Long transactionId) {
        if (!transactionService.getTransactionById(transactionId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        transactionService.completeTransaction(transactionId);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/date-range")
    @Operation(summary = "Get transactions by date range", description = "Get transactions within a date range")
    public ResponseEntity<List<Transaction>> getTransactionsBetweenDates(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {
        List<Transaction> transactions = transactionService.getTransactionsBetweenDates(startDate, endDate);
        return ResponseEntity.ok(transactions);
    }

    @GetMapping("/stats/total-buy-volume")
    @Operation(summary = "Get total buy volume", description = "Get total volume of completed buy transactions")
    public ResponseEntity<Double> getTotalBuyVolume() {
        Double totalVolume = transactionService.getTotalBuyVolume();
        return ResponseEntity.ok(totalVolume);
    }

    @GetMapping("/hash/{transactionHash}")
    @Operation(summary = "Get transaction by hash", description = "Retrieve a transaction by its hash")
    public ResponseEntity<Transaction> getTransactionByHash(@PathVariable String transactionHash) {
        Optional<Transaction> transaction = transactionService.getTransactionByHash(transactionHash);
        return transaction.map(ResponseEntity::ok)
                         .orElse(ResponseEntity.notFound().build());
    }
}
```

### SmartContractController
```java
package com.crypto.trading.controller;

import com.crypto.trading.entity.SmartContract;
import com.crypto.trading.entity.User;
import com.crypto.trading.service.SmartContractService;
import com.crypto.trading.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/smart-contracts")
@Tag(name = "Smart Contract Management", description = "APIs for managing smart contracts")
public class SmartContractController {

    @Autowired
    private SmartContractService smartContractService;

    @Autowired
    private UserService userService;

    @GetMapping
    @Operation(summary = "Get all smart contracts", description = "Retrieve all smart contracts")
    public ResponseEntity<List<SmartContract>> getAllSmartContracts() {
        List<SmartContract> contracts = smartContractService.getAllSmartContracts();
        return ResponseEntity.ok(contracts);
    }

    @GetMapping("/{contractId}")
    @Operation(summary = "Get smart contract by ID", description = "Retrieve a specific smart contract by ID")
    public ResponseEntity<SmartContract> getSmartContractById(@PathVariable Long contractId) {
        Optional<SmartContract> contract = smartContractService.getSmartContractById(contractId);
        return contract.map(ResponseEntity::ok)
                      .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/owner/{ownerId}")
    @Operation(summary = "Get contracts by owner", description = "Get all smart contracts for a specific owner")
    public ResponseEntity<List<SmartContract>> getSmartContractsByOwnerId(@PathVariable Long ownerId) {
        List<SmartContract> contracts = smartContractService.getSmartContractsByOwnerId(ownerId);
        return ResponseEntity.ok(contracts);
    }

    @PostMapping
    @Operation(summary = "Create new smart contract", description = "Create a new smart contract")
    public ResponseEntity<?> createSmartContract(@Valid @RequestBody SmartContract smartContract) {
        Optional<User> owner = userService.getUserById(smartContract.getOwner().getUserId());
        if (!owner.isPresent()) {
            return ResponseEntity.badRequest().body("Owner not found!");
        }

        smartContract.setOwner(owner.get());
        smartContract.setStatus("ACTIVE");
        SmartContract savedContract = smartContractService.saveSmartContract(smartContract);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedContract);
    }

    @PutMapping("/{contractId}")
    @Operation(summary = "Update smart contract", description = "Update an existing smart contract")
    public ResponseEntity<SmartContract> updateSmartContract(
            @PathVariable Long contractId,
            @Valid @RequestBody SmartContract smartContract) {
        if (!smartContractService.getSmartContractById(contractId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        smartContract.setContractId(contractId);
        SmartContract updatedContract = smartContractService.saveSmartContract(smartContract);
        return ResponseEntity.ok(updatedContract);
    }

    @DeleteMapping("/{contractId}")
    @Operation(summary = "Delete smart contract", description = "Delete a smart contract by ID")
    public ResponseEntity<Void> deleteSmartContract(@PathVariable Long contractId) {
        if (!smartContractService.getSmartContractById(contractId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        smartContractService.deleteSmartContract(contractId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{contractId}/status")
    @Operation(summary = "Update contract status", description = "Update the status of a smart contract")
    public ResponseEntity<Void> updateContractStatus(
            @PathVariable Long contractId,
            @RequestParam String status) {
        if (!smartContractService.getSmartContractById(contractId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        smartContractService.updateContractStatus(contractId, status);
        return ResponseEntity.ok().build();
    }

    @PutMapping("/{contractId}/deactivate")
    @Operation(summary = "Deactivate contract", description = "Deactivate a smart contract")
    public ResponseEntity<Void> deactivateContract(@PathVariable Long contractId) {
        if (!smartContractService.getSmartContractById(contractId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        smartContractService.deactivateContract(contractId);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/search")
    @Operation(summary = "Search contracts by name", description = "Search smart contracts by name")
    public ResponseEntity<List<SmartContract>> searchContractsByName(@RequestParam String contractName) {
        List<SmartContract> contracts = smartContractService.searchContractsByName(contractName);
        return ResponseEntity.ok(contracts);
    }

    @GetMapping("/status/{status}")
    @Operation(summary = "Get contracts by status", description = "Get all smart contracts with specific status")
    public ResponseEntity<List<SmartContract>> getContractsByStatus(@PathVariable String status) {
        List<SmartContract> contracts = smartContractService.getSmartContractsByStatus(status);
        return ResponseEntity.ok(contracts);
    }
}
```

### BlockchainDataController
```java
package com.crypto.trading.controller;

import com.crypto.trading.entity.BlockchainData;
import com.crypto.trading.service.BlockchainDataService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/blockchain")
@Tag(name = "Blockchain Data Management", description = "APIs for managing blockchain data")
public class BlockchainDataController {

    @Autowired
    private BlockchainDataService blockchainDataService;

    @GetMapping("/blocks")
    @Operation(summary = "Get all blocks", description = "Retrieve all blockchain blocks")
    public ResponseEntity<List<BlockchainData>> getAllBlocks() {
        List<BlockchainData> blocks = blockchainDataService.getAllBlocks();
        return ResponseEntity.ok(blocks);
    }

    @GetMapping("/blocks/{blockId}")
    @Operation(summary = "Get block by ID", description = "Retrieve a specific block by ID")
    public ResponseEntity<BlockchainData> getBlockById(@PathVariable Long blockId) {
        Optional<BlockchainData> block = blockchainDataService.getBlockById(blockId);
        return block.map(ResponseEntity::ok)
                   .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/blocks/hash/{blockHash}")
    @Operation(summary = "Get block by hash", description = "Retrieve a block by its hash")
    public ResponseEntity<BlockchainData> getBlockByHash(@PathVariable String blockHash) {
        Optional<BlockchainData> block = blockchainDataService.getBlockByHash(blockHash);
        return block.map(ResponseEntity::ok)
                   .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping("/blocks")
    @Operation(summary = "Create new block", description = "Create a new blockchain block")
    public ResponseEntity<BlockchainData> createBlock(@Valid @RequestBody BlockchainData blockchainData) {
        BlockchainData savedBlock = blockchainDataService.saveBlock(blockchainData);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedBlock);
    }

    @PutMapping("/blocks/{blockId}")
    @Operation(summary = "Update block", description = "Update an existing blockchain block")
    public ResponseEntity<BlockchainData> updateBlock(
            @PathVariable Long blockId,
            @Valid @RequestBody BlockchainData blockchainData) {
        if (!blockchainDataService.getBlockById(blockId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        blockchainData.setBlockId(blockId);
        BlockchainData updatedBlock = blockchainDataService.saveBlock(blockchainData);
        return ResponseEntity.ok(updatedBlock);
    }

    @DeleteMapping("/blocks/{blockId}")
    @Operation(summary = "Delete block", description = "Delete a blockchain block by ID")
    public ResponseEntity<Void> deleteBlock(@PathVariable Long blockId) {
        if (!blockchainDataService.getBlockById(blockId).isPresent()) {
            return ResponseEntity.notFound().build();
        }
        blockchainDataService.deleteBlock(blockId);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/blocks/date-range")
    @Operation(summary = "Get blocks by date range", description = "Get blocks within a date range")
    public ResponseEntity<List<BlockchainData>> getBlocksBetweenDates(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {
        List<BlockchainData> blocks = blockchainDataService.getBlocksBetweenDates(startDate, endDate);
        return ResponseEntity.ok(blocks);
    }

    @GetMapping("/blocks/latest")
    @Operation(summary = "Get latest blocks", description = "Get blocks ordered by timestamp (latest first)")
    public ResponseEntity<List<BlockchainData>> getLatestBlocks() {
        List<BlockchainData> blocks = blockchainDataService.getLatestBlocks();
        return ResponseEntity.ok(blocks);
    }

    @GetMapping("/blocks/difficulty/{minDifficulty}")
    @Operation(summary = "Get blocks by difficulty", description = "Get blocks with minimum difficulty level")
    public ResponseEntity<List<BlockchainData>> getBlocksWithMinDifficulty(@PathVariable Integer minDifficulty) {
        List<BlockchainData> blocks = blockchainDataService.getBlocksWithMinDifficulty(minDifficulty);
        return ResponseEntity.ok(blocks);
    }
}
```

## 8. Application Properties

```properties
# application.properties
# Database Configuration
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:XE
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.Oracle12cDialect
spring.jpa.open-in-view=false

# Connection Pool Configuration
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=60000
spring.datasource.hikari.idle-timeout=300000

# Server Configuration
server.port=8080
server.servlet.context-path=/crypto-trading

# Logging Configuration
logging.level.com.crypto.trading=DEBUG
logging.level.org.springframework.jdbc.core=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Swagger/OpenAPI Configuration
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method

# Jackson Configuration
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.time-zone=UTC

# Transaction Management
spring.transaction.rollback-on-commit-failure=true
```

## 9. Maven Dependencies (pom.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.crypto.trading</groupId>
    <artifactId>crypto-trading-platform</artifactId>
    <version>1.0.0</version>
    <name>crypto-trading-platform</name>
    <description>Crypto Trading Platform Backend</description>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Oracle JDBC Driver -->
        <dependency>
            <groupId>com.oracle.database.jdbc</groupId>
            <artifactId>ojdbc11</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Swagger/OpenAPI Documentation -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.2.0</version>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- JSON Processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

## 10. Usage Instructions

### Running the Application
1. Install Oracle Database and create the schema using the provided SQL script
2. Update `application.properties` with your database credentials
3. Run `mvn clean install` to build the project
4. Run `mvn spring-boot:run` or run the main class directly
5. Access Swagger UI at `http://localhost:8080/crypto-trading/swagger-ui.html`

### API Endpoints Summary
- **Currencies**: `/api/currencies` - Manage cryptocurrencies
- **Users**: `/api/users` - User management and registration
- **Wallets**: `/api/wallets` - Wallet operations
- **Transactions**: `/api/transactions` - Transaction processing
- **Smart Contracts**: `/api/smart-contracts` - Smart contract management
- **Blockchain**: `/api/blockchain` - Blockchain data operations

### Key Features
- Full CRUD operations for all entities
- RESTful API design with proper HTTP status codes
- Swagger documentation for API testing
- JPA/Hibernate for ORM mapping
- Spring JDBC for custom queries
- Transaction management with @Transactional
- Validation using Jakarta Bean Validation
- Proper error handling and response formatting

This backend provides a solid foundation for your crypto trading platform with all requested technologies integrated.
