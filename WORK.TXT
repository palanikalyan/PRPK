// TransactionService.java
package com.cryptotrading.service;

import com.cryptotrading.model.Transaction;
import com.cryptotrading.utils.DatabaseConnection;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class TransactionService {
    
    public List<Transaction> getUserTransactions(Long userId) throws SQLException {
        return getUserTransactions(userId, 50); // Default to last 50 transactions
    }
    
    public List<Transaction> getUserTransactions(Long userId, int limit) throws SQLException {
        String query = "SELECT transaction_id, user_id, transaction_type, from_currency, to_currency, " +
                      "amount, price_per_unit, total_value, transaction_fee, status, transaction_hash, " +
                      "created_at, completed_at FROM DC_Transactions " +
                      "WHERE user_id = ? ORDER BY created_at DESC " +
                      "FETCH FIRST ? ROWS ONLY";
        
        Connection conn = DatabaseConnection.getConnection();
        List<Transaction> transactions = new ArrayList<>();
        
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, userId);
            stmt.setInt(2, limit);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                transactions.add(mapResultSetToTransaction(rs));
            }
        }
        
        return transactions;
    }
    
    public Transaction getTransactionById(Long transactionId) throws SQLException {
        String query = "SELECT transaction_id, user_id, transaction_type, from_currency, to_currency, " +
                      "amount, price_per_unit, total_value, transaction_fee, status, transaction_hash, " +
                      "created_at, completed_at FROM DC_Transactions WHERE transaction_id = ?";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, transactionId);
            ResultSet rs = stmt.executeQuery();
            
            if (rs.next()) {
                return mapResultSetToTransaction(rs);
            }
        }
        
        return null;
    }
    
    public List<Transaction> getTransactionsByType(Long userId, String transactionType) throws SQLException {
        String query = "SELECT transaction_id, user_id, transaction_type, from_currency, to_currency, " +
                      "amount, price_per_unit, total_value, transaction_fee, status, transaction_hash, " +
                      "created_at, completed_at FROM DC_Transactions " +
                      "WHERE user_id = ? AND transaction_type = ? ORDER BY created_at DESC";
        
        Connection conn = DatabaseConnection.getConnection();
        List<Transaction> transactions = new ArrayList<>();
        
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, userId);
            stmt.setString(2, transactionType);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                transactions.add(mapResultSetToTransaction(rs));
            }
        }
        
        return transactions;
    }
    
    public List<Transaction> getTransactionsByStatus(Long userId, String status) throws SQLException {
        String query = "SELECT transaction_id, user_id, transaction_type, from_currency, to_currency, " +
                      "amount, price_per_unit, total_value, transaction_fee, status, transaction_hash, " +
                      "created_at, completed_at FROM DC_Transactions " +
                      "WHERE user_id = ? AND status = ? ORDER BY created_at DESC";
        
        Connection conn = DatabaseConnection.getConnection();
        List<Transaction> transactions = new ArrayList<>();
        
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setLong(1, userId);
            stmt.setString(2, status);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {
                transactions.add(mapResultSetToTransaction(rs));
            }
        }
        
        return transactions;
    }
    
    public boolean updateTransactionStatus(Long transactionId, String newStatus) throws SQLException {
        String query = "UPDATE DC_Transactions SET status = ?, completed_at = ? WHERE transaction_id = ?";
        
        Connection conn = DatabaseConnection.getConnection();
        try (PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setString(1, newStatus);
            
            if ("COMPLETED".equals(newStatus)) {
                stmt.setTimestamp(2, Timestamp.valueOf(LocalDateTime.now()));
            } else {
                stmt.setNull(2, Types.TIMESTAMP);
            }
            
            stmt.setLong(3, transactionId);
            
            int rowsAffected = stmt.executeUpdate();
            DatabaseConnection.commit();
            return rowsAffected > 0;
        } catch (SQLException e) {
            DatabaseConnection.rollback();
            throw e;
        }
    }
    
    private Transaction mapResultSetToTransaction(ResultSet rs) throws SQLException {
        Transaction transaction = new Transaction();
        transaction.setTransactionId(rs.getLong("transaction_id"));
        transaction.setUserId(rs.getLong("user_id"));
        transaction.setTransactionType(rs.getString("transaction_type"));
        transaction.setFromCurrency(rs.getString("from_currency"));
        transaction.setToCurrency(rs.getString("to_currency"));
        transaction.setAmount(rs.getBigDecimal("amount"));
        transaction.setPricePerUnit(rs.getBigDecimal("price_per_unit"));
        transaction.setTotalValue(rs.getBigDecimal("total_value"));
        transaction.setTransactionFee(rs.getBigDecimal("transaction_fee"));
        transaction.setStatus(rs.getString("status"));
        transaction.setTransactionHash(rs.getString("transaction_hash"));
        transaction.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
        
        Timestamp completedAt = rs.getTimestamp("completed_at");
        if (completedAt != null) {
            transaction.setCompletedAt(completedAt.toLocalDateTime());
        }
        
        return transaction;
    }
}
