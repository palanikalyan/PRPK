Okay, here is the implementation for `UserDao.java`, designed to interact with the `DC_Users` table and support the operations needed by the `loginService`.

```java
// UserDao.java
package Dao;

import Model.DC_Users_KK; // Assuming DC_Users_KK is in the Model package
import utils.DBUtil; // Assuming DBUtil is in the utils package
import utils.ErrorHandler; // Assuming ErrorHandler is in the utils package

import java.sql.*;

public class UserDao {

    /**
     * Inserts a new user record into the DC_Users table.
     * Automatically retrieves and sets the generated user ID.
     *
     * @param con           The active SQL Connection.
     * @param username      The username for the new user.
     * @param encryptedPin  The hashed PIN for the new user.
     * @param email         The email address for the new user.
     * @param phoneNumber   The phone number for the new user.
     * @return The generated user ID if the insertion is successful, otherwise -1.
     * @throws SQLException If a database access error occurs.
     */
    public long insert(Connection con, String username, String encryptedPin, String email, String phoneNumber) throws SQLException {
        // SQL statement to insert a new user and return the generated ID
        String query = "INSERT INTO DC_Users (username, encrypted_pin, email, phone_number) VALUES (?, ?, ?, ?)";
        long userId = -1;

        // Use PreparedStatement to prevent SQL injection and leverage try-with-resources
        try (PreparedStatement ps = con.prepareStatement(query, Statement.RETURN_GENERATED_KEYS)) {
            ps.setString(1, username);
            ps.setString(2, encryptedPin);
            ps.setString(3, email);
            ps.setString(4, phoneNumber);

            int affectedRows = ps.executeUpdate();

            if (affectedRows > 0) {
                // Retrieve the auto-generated user ID
                try (ResultSet generatedKeys = ps.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        userId = generatedKeys.getLong(1);
                    } else {
                        // This should ideally not happen if executeUpdate returned > 0
                        throw new SQLException("Creating user failed, no ID obtained.");
                    }
                }
            } else {
                 // If affectedRows is 0, it means no row was inserted.
                 throw new SQLException("Creating user failed, no rows affected.");
            }
        } catch (SQLException e) {
            // Re-throw SQLException to be handled by the caller (e.g., LoginService)
            throw e;
        }
        return userId;
    }

    /**
     * Finds a user record by their username.
     *
     * @param con      The active SQL Connection.
     * @param username The username to search for.
     * @return A DC_Users_KK object representing the user if found, otherwise null.
     * @throws SQLException If a database access error occurs.
     */
    public DC_Users_KK findByUsername(Connection con, String username) throws SQLException {
        String query = "SELECT * FROM DC_Users WHERE username = ?";
        DC_Users_KK user = null;

        try (PreparedStatement ps = con.prepareStatement(query)) {
            ps.setString(1, username);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    user = mapResultSetToUser(rs);
                }
            }
        }
        return user;
    }
    
    /**
     * Finds a user record by their user ID.
     *
     * @param con     The active SQL Connection.
     * @param userId  The ID of the user to search for.
     * @return A DC_Users_KK object representing the user if found, otherwise null.
     * @throws SQLException If a database access error occurs.
     */
    public DC_Users_KK findById(Connection con, long userId) throws SQLException {
        String query = "SELECT * FROM DC_Users WHERE user_id = ?";
        DC_Users_KK user = null;

        try (PreparedStatement ps = con.prepareStatement(query)) {
            ps.setLong(1, userId);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    user = mapResultSetToUser(rs);
                }
            }
        }
        return user;
    }

    /**
     * Updates an existing user record in the DC_Users table.
     *
     * @param con  The active SQL Connection.
     * @param user The DC_Users_KK object containing the updated user data.
     * @return true if the update was successful (at least one row affected), false otherwise.
     * @throws SQLException If a database access error occurs.
     */
    public boolean update(Connection con, DC_Users_KK user) throws SQLException {
        String query = "UPDATE DC_Users SET username = ?, encrypted_pin = ?, email = ?, phone_number = ? WHERE user_id = ?";
        int affectedRows = 0;

        try (PreparedStatement ps = con.prepareStatement(query)) {
            ps.setString(1, user.getUsername());
            ps.setString(2, user.getEncrypted_pin());
            ps.setString(3, user.getEmail());
            ps.setString(4, user.getPhone_number());
            ps.setLong(5, user.getUser_id());

            affectedRows = ps.executeUpdate();
        }
        return affectedRows > 0;
    }

    /**
     * Deletes a user record from the DC_Users table by their ID.
     * (Optional, but good for completeness)
     *
     * @param con     The active SQL Connection.
     * @param userId  The ID of the user to delete.
     * @return true if the deletion was successful, false otherwise.
     * @throws SQLException If a database access error occurs.
     */
    public boolean delete(Connection con, long userId) throws SQLException {
        String query = "DELETE FROM DC_Users WHERE user_id = ?";
        int affectedRows = 0;

        try (PreparedStatement ps = con.prepareStatement(query)) {
            ps.setLong(1, userId);
            affectedRows = ps.executeUpdate();
        }
        return affectedRows > 0;
    }

    /**
     * Helper method to map a ResultSet row to a DC_Users_KK object.
     *
     * @param rs The ResultSet from a query.
     * @return A populated DC_Users_KK object.
     * @throws SQLException If a database access error occurs while reading the ResultSet.
     */
    private DC_Users_KK mapResultSetToUser(ResultSet rs) throws SQLException {
        DC_Users_KK user = new DC_Users_KK();
        user.setUser_id(rs.getLong("user_id"));
        user.setUsername(rs.getString("username"));
        user.setEncrypted_pin(rs.getString("encrypted_pin")); // Store the HASHED PIN
        user.setEmail(rs.getString("email"));
        user.setPhone_number(rs.getString("phone_number"));
        // if there's a status column: user.setStatus(rs.getString("status"));
        return user;
    }
}
```

**Key features of this `UserDao` implementation:**

*   **Uses `Connection`:** It accepts an active `Connection` object, allowing the `Service` layer to manage transactions (commit/rollback).
*   **`PreparedStatement`:** Prevents SQL injection attacks.
*   **`ResultSet` Handling:** Properly iterates through results and maps them to the `DC_Users_KK` model.
*   **Error Handling:** Declares `throws SQLException` so the caller (like `loginService`) can handle specific database errors using `try-catch` blocks or the `ErrorHandler`.
*   **`RETURN_GENERATED_KEYS`:** Used in the `insert` method to reliably get the auto-generated `userId`.
*   **Helper Method:** `mapResultSetToUser` reduces code duplication when retrieving user data.
